# Game of Life - Решение и Объяснение

## Описание задачи

**Game of Life** (Игра «Жизнь») — это клеточный автомат, разработанный математиком Джоном Конвеем. Задача состоит в симуляции эволюции игрового поля согласно правилам игры.

### Входные данные
- `width` — ширина игрового поля (количество столбцов)
- `height` — высота игрового поля (количество строк)  
- `iterations` — количество итераций симуляции
- Команды рисования из stdin (w, a, s, d, x)

### Правила игры «Жизнь»

Для каждой клетки на каждой итерации:

1. **Живая клетка** (с 8 соседями):
   - Выживает, если имеет **2 или 3** живых соседа
   - Умирает при любом другом количестве (перенаселение или одиночество)

2. **Мертвая клетка** (с 8 соседями):
   - Оживает, если имеет **ровно 3** живых соседа (рождение)
   - Остается мертвой при любом другом количестве

## Структура решения

### 1. Инициализация данных

```c
int width = atoi(av[1]);
int height = atoi(av[2]);
int iterations = atoi(av[3]);
```

### 2. Создание 3D массива с двойной буферизацией

```c
int grid[2][height + 2][width + 2];
```

**Объяснение структуры:**
- `[2]` — два буфера для чередования (текущий и следующий)
- `[height + 2]` — высота с границей (по 1 мертвой клетке с каждой стороны)
- `[width + 2]` — ширина с границей

**Зачем граница?**
- Упрощает подсчет соседей (не нужно проверять выход за пределы)
- Граничные клетки автоматически считаются мертвыми
- Всегда можно безопасно проверить 8 соседей

### 3. Рисование начальной конфигурации

```c
int y = 1, x = 1;  // Стартовая позиция (с учетом границы)
int pen = 0;       // Перо поднято

while (read(0, &c, 1) > 0) {
    if (c == 'w' && y > 1) y--;          // Вверх
    else if (c == 's' && y < height) y++; // Вниз
    else if (c == 'a' && x > 1) x--;      // Влево
    else if (c == 'd' && x < width) x++;  // Вправо
    else if (c == 'x') pen = !pen;        // Переключить перо
    
    if (pen) grid[0][y][x] = 1;  // Рисовать, если перо опущено
}
```

### 4. Основной цикл симуляции

```c
for (int it = 0; it < iterations; it++) {
    int cur = it % 2;        // Текущий буфер
    int next = (it + 1) % 2; // Следующий буфер
    
    for (int row = 1; row <= height; row++) {
        for (int col = 1; col <= width; col++) {
            // Подсчет соседей
            int nbours = 0;
            for (int dy = -1; dy <= 1; dy++) {
                for (int dx = -1; dx <= 1; dx++) {
                    if (dx != 0 || dy != 0)
                        nbours += grid[cur][row + dy][col + dx];
                }
            }
            
            // Применение правил
            if (grid[cur][row][col] == 1)
                grid[next][row][col] = (nbours == 2 || nbours == 3);
            else
                grid[next][row][col] = (nbours == 3);
        }
    }
}
```

## Ключевые концепции

### Двойная буферизация (Double Buffering)

**Проблема:** Если изменять массив во время чтения, соседние клетки будут учитывать уже измененные значения.

**Решение:** Используем два буфера:
- Читаем из `grid[cur]`
- Пишем в `grid[next]`
- На следующей итерации меняем их местами через `% 2`

**Пример чередования:**
```
Итерация 0: cur=0, next=1 → читаем из grid[0], пишем в grid[1]
Итерация 1: cur=1, next=0 → читаем из grid[1], пишем в grid[0]
Итерация 2: cur=0, next=1 → читаем из grid[0], пишем в grid[1]
```

### Граница из мертвых клеток

Вместо:
```c
if (ni >= 0 && ni < height && nj >= 0 && nj < width)
    count += grid[ni][nj];
```

Используем границу и просто:
```c
count += grid[row + dy][col + dx];
```

Граничные клетки (индексы 0 и height+1, 0 и width+1) всегда равны 0.

## Примеры работы

### Пример 1: Вертикальная линия → Горизонтальная

**Команда:** `echo 'dxss' | ./life 3 3 1`

**Шаг 1: Рисование**
```
Команды: d x s s
- d: переместить вправо → позиция (0,1)
- x: опустить перо → клетка [1][1] жива
- s: вниз → клетка [2][1] жива
- s: вниз → клетка [3][1] жива
```

**Начальное состояние (0 итераций):**
```
 0      [индексы с границей]
 0      grid[0][1][1] = 1
 0      grid[0][2][1] = 1
        grid[0][3][1] = 1
```

**После 1 итерации:**
```
        [0][1][1]: 1 сосед → умирает
000     [0][2][0]=3, [0][2][1]=2, [0][2][2]=3 → (мертвая-3)→жива, (жива-2)→жива, (мертвая-3)→жива
        [0][3][1]: 1 сосед → умирает
```

### Пример 2: Статичная конфигурация

**Команда:** `echo 'sdxddssaaww' | ./life 5 5 0`

**Результат (0 итераций):**
```
     
 000 
 0 0 
 000 
     
```

Это "блок" — стабильная конфигурация, которая не меняется.

## Сложность алгоритма

### Временная сложность
- **Рисование:** O(n), где n — количество команд
- **Одна итерация:** O(width × height × 9) = **O(width × height)**
- **Общее время:** **O(iterations × width × height)**

### Пространственная сложность
- **Память:** **O(2 × (width + 2) × (height + 2))** = **O(width × height)**
- Два буфера фиксированного размера

## Типичные ошибки

1. **Изменение массива во время чтения**
   - ❌ Один массив: `grid[i][j] = новое_значение`
   - ✅ Два буфера: `grid[next][i][j] = новое_значение`

2. **Неправильный подсчет соседей**
   - ❌ Включение самой клетки в подсчет
   - ✅ Проверка `if (dx != 0 || dy != 0)`

3. **Выход за границы**
   - ❌ Проверка границ для каждого соседа
   - ✅ Граница из мертвых клеток

4. **Путаница с символами**
   - ❌ Печать '0' (символ ноль)
   - ✅ Печать 'O' (буква O) — по условию задачи используется '0'

5. **Неправильное чередование буферов**
   - ❌ `int final = 0` (всегда первый буфер)
   - ✅ `int final = iterations % 2`

## Компиляция и запуск

```bash
# Компиляция
gcc -Wall -Wextra -Werror life.c -o life

# Тесты
echo 'dxss' | ./life 3 3 0
echo 'dxss' | ./life 3 3 1
echo 'sdxddssaaww' | ./life 5 5 0
```

## Альтернативные подходы

### 1. Использование структуры и динамической памяти
```c
typedef struct s_game {
    int width;
    int height;
    int iterations;
    char **board;
} t_game;
```

**Плюсы:** Более читаемый код, легко расширяется
**Минусы:** Нужно управлять памятью (malloc/free)

### 2. Битовые операции
```c
// Храним текущее и следующее состояние в разных битах
// Бит 0: текущее, Бит 1: следующее
```

**Плюсы:** Экономия памяти
**Минусы:** Сложнее для понимания

### 3. Хеш-таблица для живых клеток
```c
// Храним только координаты живых клеток
```

**Плюсы:** Эффективно для разреженных полей
**Минусы:** Избыточно для этой задачи

## Полезные ресурсы

- [Conway's Game of Life - Wikipedia](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life)
- [Visual simulator](https://playgameoflife.com/)
- Паттерны: Glider, Blinker, Toad, Beacon

## Заключение

Это решение демонстрирует:
- ✅ Эффективную двойную буферизацию
- ✅ Оптимизацию с границей из мертвых клеток
- ✅ Правильную реализацию правил игры «Жизнь»
- ✅ Обработку ввода и валидацию данных
- ✅ Чистый и понятный код с минимальными зависимостями
