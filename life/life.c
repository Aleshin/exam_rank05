/* ************************************************************************** */
/*                                                                            */
/*   РЕШЕНИЕ: Game of Life (Игра «Жизнь»)                                    */
/*   EXAM RANK 05 - LEVEL 1                                                  */
/*                                                                            */
/*   Это решение использует оптимизированный подход с двумя буферами         */
/*   для симуляции игры «Жизнь» Конвея (Conway's Game of Life)              */
/*                                                                            */
/* ************************************************************************** */

#include <unistd.h>   // для read(), write()
#include <stdlib.h>   // для atoi(), malloc(), free()

/* ************************************************************************** */
/*                             ГЛАВНАЯ ФУНКЦИЯ                                */
/* ************************************************************************** */

int main(int ac, char** av)
{
    /* ====================================================================== */
    /* ШАГ 1: ВАЛИДАЦИЯ АРГУМЕНТОВ                                           */
    /* ====================================================================== */
    
    // Программа должна получить ровно 3 аргумента (+ имя программы = 4)
    if (ac != 4)
        return 1;

    // Парсим аргументы командной строки
    int width = atoi(av[1]);        // Ширина поля (количество столбцов)
    int height = atoi(av[2]);       // Высота поля (количество строк)
    int iterations = atoi(av[3]);   // Количество итераций игры

    // Проверяем, что все значения положительные
    if (width <= 0 || height <= 0 || iterations < 0)
        return 1;

    /* ====================================================================== */
    /* ШАГ 2: ИНИЦИАЛИЗАЦИЯ ПЕРЕМЕННЫХ ДЛЯ РИСОВАНИЯ                         */
    /* ====================================================================== */
    
    // Переменные для отслеживания позиции "пера"
    // +1 потому что мы создаем границу в 1 клетку вокруг поля
    // Это упрощает проверку соседей (не нужно проверять границы)
    int y = 1;      // Текущая позиция по вертикали (строка)
    int x = 1;      // Текущая позиция по горизонтали (столбец)
    int pen = 0;    // Состояние пера: 0 = поднято (не рисует), 1 = опущено (рисует)
    
    /* ====================================================================== */
    /* ШАГ 3: СОЗДАНИЕ 3D МАССИВА ДЛЯ ДВОЙНОЙ БУФЕРИЗАЦИИ                    */
    /* ====================================================================== */
    
    /*
     * ОБЪЯСНЕНИЕ СТРУКТУРЫ ДАННЫХ:
     * 
     * Используем 3D массив: grid[2][height+2][width+2]
     * 
     * - Первое измерение [2]: два буфера для чередования
     *   · grid[0] - текущее состояние
     *   · grid[1] - следующее состояние
     *   Чередуем их на каждой итерации, чтобы избежать лишнего копирования
     * 
     * - Второе измерение [height+2]: строки с границей
     *   · Добавляем +2 для создания границы из мертвых клеток (по 1 с каждой стороны)
     *   · Строка 0 и строка height+1 всегда остаются 0 (мертвыми)
     *   · Реальное игровое поле: строки от 1 до height
     * 
     * - Третье измерение [width+2]: столбцы с границей
     *   · Добавляем +2 для создания границы из мертвых клеток
     *   · Столбец 0 и столбец width+1 всегда остаются 0 (мертвыми)
     *   · Реальное игровое поле: столбцы от 1 до width
     * 
     * ПРЕИМУЩЕСТВА ЭТОГО ПОДХОДА:
     * 1. Не нужно проверять границы при подсчете соседей
     * 2. Граничные клетки автоматически считаются мертвыми
     * 3. Упрощается логика подсчета соседей (всегда 8 соседей)
     */
    int grid[2][height + 2][width + 2];
    
    // Буфер для чтения команд по одному символу
    char c;

    /* ====================================================================== */
    /* ШАГ 4: ИНИЦИАЛИЗАЦИЯ ИГРОВОГО ПОЛЯ (ОБНУЛЕНИЕ)                        */
    /* ====================================================================== */
    
    // Заполняем оба буфера нулями (все клетки мертвы)
    for (int d = 0; d < 2; d++)              // d - dimension (измерение буфера)
    {
        for (int row = 0; row < height + 2; row++)    // Проходим по всем строкам
        {
            for (int col = 0; col < width + 2; col++) // Проходим по всем столбцам
                grid[d][row][col] = 0;                // Инициализируем мертвой клеткой
        }
    }

    /* ====================================================================== */
    /* ШАГ 5: ЧТЕНИЕ КОМАНД И РИСОВАНИЕ НАЧАЛЬНОЙ КОНФИГУРАЦИИ                */
    /* ====================================================================== */
    
    /*
     * ЛОГИКА РИСОВАНИЯ:
     * 
     * Читаем команды из stdin по одному символу до EOF
     * Обрабатываем каждую команду:
     * - w/a/s/d: перемещение пера
     * - x: переключение состояния пера (рисует/не рисует)
     * 
     * Если перо опущено (pen == 1), мы отмечаем текущую клетку как живую
     */
    
    while (read(0, &c, 1) > 0)  // Читаем по одному байту из stdin
    {
        // Обработка команд перемещения (с проверкой границ)
        if (c == 'w' && y > 1)           // 'w' = вверх (up)
            y--;                          // Уменьшаем номер строки
        else if (c == 's' && y < height) // 's' = вниз (down)
            y++;                          // Увеличиваем номер строки
        else if (c == 'a' && x > 1)      // 'a' = влево (left)
            x--;                          // Уменьшаем номер столбца
        else if (c == 'd' && x < width)  // 'd' = вправо (right)
            x++;                          // Увеличиваем номер столбца
        else if (c == 'x')               // 'x' = переключить перо
            pen = !pen;                   // Инвертируем состояние: 0->1 или 1->0
        
        // Если перо опущено, отмечаем текущую позицию как живую клетку
        if (pen)
            grid[0][y][x] = 1;  // 1 = живая клетка
    }

    /* ====================================================================== */
    /* ШАГ 6: СИМУЛЯЦИЯ ИГРЫ «ЖИЗНЬ» (ОСНОВНОЙ ЦИКЛ)                         */
    /* ====================================================================== */
    
    /*
     * АЛГОРИТМ ИГРЫ «ЖИЗНЬ» КОНВЕЯ:
     * 
     * Для каждой клетки на каждой итерации:
     * 1. Подсчитываем количество живых соседей (8 клеток вокруг)
     * 2. Применяем правила:
     *    - Живая клетка выживает, если у нее 2 или 3 живых соседа
     *    - Живая клетка умирает при любом другом количестве соседей
     *    - Мертвая клетка оживает, если у нее ровно 3 живых соседа
     *    - Мертвая клетка остается мертвой при любом другом количестве
     * 
     * ТЕХНИКА ДВОЙНОЙ БУФЕРИЗАЦИИ:
     * - Читаем из grid[cur] (текущий буфер)
     * - Пишем в grid[next] (следующий буфер)
     * - На следующей итерации меняем их местами (через модуль 2)
     * - Это избегает перезаписи данных во время вычислений
     */
    
    for (int it = 0; it < iterations; it++)  // Цикл по количеству итераций
    {
        // Определяем, какой буфер текущий, а какой - следующий
        int cur = it % 2;        // Индекс текущего буфера (0 или 1)
        int next = (it + 1) % 2; // Индекс следующего буфера (1 или 0)
        
        // Проходим по всем клеткам игрового поля (без границ)
        for (int row = 1; row <= height; row++)
        {
            for (int col = 1; col <= width; col++)
            {
                /* ========================================================== */
                /* ШАГ 6.1: ПОДСЧЕТ ЖИВЫХ СОСЕДЕЙ                             */
                /* ========================================================== */
                
                /*
                 * ПОДСЧЕТ СОСЕДЕЙ:
                 * 
                 * Для клетки (row, col) проверяем 8 соседних клеток:
                 * 
                 *   (row-1, col-1)  (row-1, col)  (row-1, col+1)
                 *   (row,   col-1)  [ТЕКУЩАЯ]     (row,   col+1)
                 *   (row+1, col-1)  (row+1, col)  (row+1, col+1)
                 * 
                 * dy (delta y) проходит значения: -1, 0, 1 (строки)
                 * dx (delta x) проходит значения: -1, 0, 1 (столбцы)
                 * Пропускаем центральную клетку (dx == 0 && dy == 0)
                 */
                
                int nbours = 0;  // Счетчик живых соседей
                
                // Проходим по всем соседним клеткам
                for (int dy = -1; dy <= 1; dy++)      // Смещение по строкам
                {
                    for (int dx = -1; dx <= 1; dx++)  // Смещение по столбцам
                    {
                        // Пропускаем центральную клетку (саму себя)
                        if (dx != 0 || dy != 0)
                        {
                            // Добавляем значение соседней клетки (0 или 1)
                            // Благодаря границе из мертвых клеток, не нужно
                            // проверять выход за пределы массива
                            nbours += grid[cur][row + dy][col + dx];
                        }
                    }
                }
                
                /* ========================================================== */
                /* ШАГ 6.2: ПРИМЕНЕНИЕ ПРАВИЛ ИГРЫ «ЖИЗНЬ»                   */
                /* ========================================================== */
                
                /*
                 * ПРАВИЛА:
                 * 1. Живая клетка (== 1):
                 *    - Выживает при 2 или 3 соседях
                 *    - Умирает при любом другом количестве
                 * 
                 * 2. Мертвая клетка (== 0):
                 *    - Оживает при ровно 3 соседях
                 *    - Остается мертвой при любом другом количестве
                 */
                
                if (grid[cur][row][col] == 1)  // Клетка в данный момент жива
                {
                    // Выживает только при 2 или 3 соседях
                    // (nbours == 2 || nbours == 3) возвращает 1 (true) или 0 (false)
                    grid[next][row][col] = (nbours == 2 || nbours == 3);
                }
                else  // Клетка в данный момент мертва
                {
                    // Оживает только при ровно 3 соседях
                    // (nbours == 3) возвращает 1 (true) или 0 (false)
                    grid[next][row][col] = (nbours == 3);
                }
            }
        }
        // После этого цикла grid[next] содержит новое состояние поля
        // На следующей итерации он станет текущим (благодаря модулю 2)
    }

    /* ====================================================================== */
    /* ШАГ 7: ВЫВОД ФИНАЛЬНОГО СОСТОЯНИЯ ПОЛЯ                                */
    /* ====================================================================== */
    
    /*
     * ОПРЕДЕЛЕНИЕ ФИНАЛЬНОГО БУФЕРА:
     * 
     * После всех итераций нужно определить, в каком буфере финальный результат:
     * - Если iterations четное (0, 2, 4...), финал в grid[0]
     * - Если iterations нечетное (1, 3, 5...), финал в grid[1]
     * - Формула: iterations % 2 дает нам правильный индекс
     * 
     * Примеры:
     * - 0 итераций: 0 % 2 = 0 → grid[0] (начальное состояние)
     * - 1 итерация: 1 % 2 = 1 → grid[1] (после одной итерации)
     * - 2 итерации: 2 % 2 = 0 → grid[0] (после двух итераций)
     */
    
    int final = iterations % 2;  // Индекс буфера с финальным состоянием
    
    // Проходим по всем клеткам игрового поля и выводим их
    for (int row = 1; row <= height; row++)
    {
        for (int col = 1; col <= width; col++)
        {
            // Выводим '0' для живой клетки, ' ' (пробел) для мертвой
            if (grid[final][row][col])
                putchar('O');  // Живая клетка = символ 'O' (буква O)
            else
                putchar(' ');  // Мертвая клетка = пробел
        }
        putchar('\n');  // Переход на новую строку после каждого ряда
    }

    /* ====================================================================== */
    /* КОНЕЦ ПРОГРАММЫ                                                        */
    /* ====================================================================== */
    
    return 0;  // Успешное завершение программы
}

/* ************************************************************************** */
/*                            ДОПОЛНИТЕЛЬНЫЕ ПОЯСНЕНИЯ                        */
/* ************************************************************************** */

/*
 * СЛОЖНОСТЬ АЛГОРИТМА:
 * - Память: O(width × height) - два буфера фиксированного размера
 * - Время на итерацию: O(width × height × 9) ≈ O(width × height)
 *   Для каждой клетки проверяем 8 соседей + саму клетку
 * - Общее время: O(iterations × width × height)
 * 
 * АЛЬТЕРНАТИВНЫЕ ПОДХОДЫ:
 * 
 * 1. Один буфер + временный массив:
 *    - Создавать temp на каждой итерации
 *    - Копировать temp обратно в основной массив
 *    - Минус: больше операций копирования
 * 
 * 2. Использование битовых масок:
 *    - Хранить текущее и следующее состояние в разных битах
 *    - Плюс: экономия памяти
 *    - Минус: более сложная логика
 * 
 * 3. Динамическое выделение памяти:
 *    - Использовать malloc для создания массива
 *    - Плюс: работает с очень большими полями
 *    - Минус: нужно управлять памятью (malloc/free)
 * 
 * ОПТИМИЗАЦИИ ЭТОГО РЕШЕНИЯ:
 * 
 * 1. Граница из мертвых клеток:
 *    - Упрощает проверку соседей
 *    - Не нужны условия для граничных случаев
 * 
 * 2. Двойная буферизация с чередованием:
 *    - Избегаем копирования данных между буферами
 *    - Просто меняем индексы (cur/next)
 * 
 * 3. Компактные условия:
 *    - (nbours == 2 || nbours == 3) возвращает 0 или 1
 *    - Можно напрямую присвоить результат булевого выражения
 * 
 * ТИПИЧНЫЕ ОШИБКИ ПРИ РЕАЛИЗАЦИИ:
 * 
 * 1. Забыть про границу +2 при создании массива
 * 2. Неправильно обработать чередование буферов
 * 3. Изменять массив во время чтения (нужно два буфера!)
 * 4. Неправильно считать соседей (включить саму клетку)
 * 5. Спутать '0' (символ ноль) и 'O' (буква O)
 * 6. Забыть проверить границы при движении пера
 * 7. Неправильно обработать состояние пера (toggle)
 */
