КОМПАКТНОЕ РЕШЕНИЕ BSQ - САМОЕ ПРОСТОЕ
=======================================

Это минимальное, но полное решение задачи bsq.
Легко понять, запомнить и модифицировать.

КОД В ОДНОМ ФАЙЛЕ (bsq.c - 130 строк)
───────────────────────────────────────

Главная идея:
1. Читай заголовок (rows, empty_char, obstacle_char, full_char)
2. Читай карту (0 для пусто, -1 для препятствия)
3. Используй DP: m[i][j] = размер наибольшего квадрата с углом в (i,j)
   - m[i][j] = min(m[i-1][j], m[i][j-1], m[i-1][j-1]) + 1
4. Выводи результат


СТРУКТУРА
─────────

t_data:
  - rows, cols: размеры
  - m: 2D массив (-1=препятствие, остальное=размер DP)
  - e, o, f: символы (empty, obstacle, full)

min3(): находит минимум из 3 чисел

read_header(): парсит заголовок, проверяет что 3 символа разные

read_map(): читает карту в int массив

find_square(): DP алгоритм (O(n*m))

print_map(): выводит результат с заполненным квадратом

free_data(): освобождает память


ЗАПОМНИТЬ
──────────

Самое важное в коде:
1. if (d->e == d->o || d->e == d->f || d->o == d->f) return 0;
   ← КРИТИЧНО! Проверяем что символы разные

2. if (d->m[i][j] != -1) { ... d->m[i][j] = min3(...) + 1; }
   ← DP: вычисляем размер квадрата

3. for (int i = 1; i < argc; i++) { ... }
   ← Обработка нескольких файлов


КОМПИЛЯЦИЯ
──────────

make

или

gcc -Wall -Wextra -Werror -o bsq bsq.c


ИСПОЛЬЗОВАНИЕ
──────────────

./bsq mapfile.txt           # из файла
cat mapfile.txt | ./bsq     # из stdin
./bsq map1.txt map2.txt     # несколько файлов


ТЕСТИРОВАНИЕ
──────────────

bash test.sh  # запустит несколько тестов


ОБЪЕМ КОДА
──────────

- bsq.c: 130 строк (весь код)
- bsq.h: 17 строк (заголовки функций)
- Makefile: 14 строк
- Итого: ~160 строк


ОСОБЕННОСТИ
────────────

✓ Компактный и понятный
✓ O(n*m) время, O(n*m) память
✓ Полная валидация
✓ Поддержка stdin и файлов
✓ Правильное разрешение конфликтов (top-left)
✓ Очистка памяти
✓ Обработка ошибок


ОТЛИЧИЯ ОТ ПОЛНОГО РЕШЕНИЯ
────────────────────────────

Это решение:
- Использует int массив вместо char (быстрее)
- Объединяет всё в один файл (проще)
- Нет разделения на модули (компактнее)
- Простой и понятный DP


ЕСЛИ ЗАБЫЛ КОД, ЗАПОМНИ:

1. Структура t_data
2. fscanf для заголовка
3. getline для карты
4. DP: m[i][j] = min3(m[i-1][j], m[i][j-1], m[i-1][j-1]) + 1
5. Вывод: если (i >= sr && i < sr+sz && j >= sc && j < sc+sz) выводим d->f
6. Освобождаем память
